
/**
 * Factory Method
 *	
 * 模式的一个原则就是封装变化，工厂方法中变化的部分是：
 * 通用逻辑中创建对象的部分不确定，需要延迟到子类来实现。
 * 抽象类负责大部分逻辑，而单独将创建对象的部分延迟到子类，
 * 每个子类之负责创建（管理）一个产品，这个跟静态工厂负责
 * 管理一些产品是有区别的，但是跟抽象工厂还是比较相似的。
 *
 * List 和 Set 都是继承自 Collection， iterator方法也是
 * Collection中定义的，Collection是一个集合的抽象，根本
 * 不知道有哪些实现类，也根本不知道实现类的具体结构，也就
 * 根本不知道具体实现类的如何迭代，所以就把生成迭代器的
 * 任务交给具体实现类去实现，这样Collection根本不关心
 * 具体的Iterator，而和Iterator接口打交道。这就是依赖倒置原则
 * 的体现，应该依赖于抽像而不应该依赖于实现。
 * 
 * 另外这个模式也是完全符合开闭原则的， 当你有新的集合结构时， 
 * 只需要实现Collection， 实现自己的迭代器。根本不需要修改现有代码。
 *
 */
package org.buzheng.study.pattern.factorymethod;